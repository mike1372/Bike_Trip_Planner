<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <title>Directions service</title>
    <style>
    html,
    body,
    #google-map {
        height: 100%;
        margin: 0px;
        padding: 0px
    }
    #wrapper {
        position: absolute;
        top: 5px;
        left: 25%;
        width: 80%;
        margin-left: -180px;
        z-index: 5;
        background-color: #fff;
        padding: 5px;
        border: 1px solid #999;
    }
    #input-panel {} .controls {
        width: 40%;
    }
    </style>

    <script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?libraries=places&sensor=false"></script>
    <!--<script src="https://maps.googleapis.com/maps/api/js?v=3.exp"></script> -->
</head>

<body>
    <div id="wrapper">
        <div id="input-panel">
            <input id="start" class="controls" type="text" placeholder="Start: ">
            <input id="end" class="controls" type="text" placeholder="End: ">
            <button id="go" onclick="calcRoute(latLongArray);">Directions</button>
        </div>
        <div class="output-panel">
            <div id="travel-distance">
                Distance:
                <span id="distance"></span>
            </div>
            <div class="output-panel">
                Travel Time:
                <span id="travel-time"></span>
            </div>
            <div class="output-panel">
                Meters to Climb:
                <span id="climb"></span>
            </div>
            <div class="output-panel">
                Total meters of Descent:
                <span id="descent"></span>
            </div>
        </div>
    </div>
    <div id="google-map"></div>
</body>

</html>

<script>
function cc(a) {
        console.log(a)
    } //debug

var directionsDisplay;
var directionsService = new google.maps.DirectionsService();
var autocomplete;
var elevation_data = null;
var elevations = [];
var distance = null;
var duration = null;
var markersArray = [];
var mapPaths = [];
var polyline;
var routes = null;
var slopes = null;
var SAMPLESIZE = 500;

function initialize() {
    var renderOptions = {
        draggable: true, //routes draggable
        hideRouteList: true,
        polylineOptions: {
            strokeOpacity: 0
        }
    };
    var melbourne = new google.maps.LatLng(-37.813776, 144.963397);
    directionsDisplay = new google.maps.DirectionsRenderer(renderOptions);
    var mapCanvas = document.getElementById('google-map');

    var mapOptions = {
        center: melbourne,
        zoom: 14,
        // change map type to ROADMAP for faster loading
        mapTypeId: google.maps.MapTypeId.ROADMAP
    };

    // provides the user with autocomplete functionality
    autocomplete = new google.maps.places.Autocomplete(
        (document.getElementById('start')), {
            types: ['geocode']
        });
    autocomplete = new google.maps.places.Autocomplete(
        (document.getElementById('end')), {
            types: ['geocode']
        });

    map = new google.maps.Map(mapCanvas, mapOptions);
    directionsDisplay.setMap(map);
    elevation_data = new google.maps.ElevationService();

    // update paths onClick.
    google.maps.event.addListener(directionsDisplay, 'routeindex_changed', updateRoutes);

    autocomplete.bindTo('bounds', map);
    directionsDisplay.setMap(map);
}

latLongArray = [
    [-0.00000000, 0.000000000],
    // [-37.8173561, 144.9674856],
    [-1.1111111111, 1.1111111111]
]

function calcRoute(latLongArray) {

    wayPointsArray = [];
    if (latLongArray.length === 2) {
        // return wayPointsArray = []; as previously defined
    } else if (latLongArray.length > 2) {

        for (i = 1; i < latLongArray.length - 1; i++) {
            cc(latLongArray[i]);
            wayPointsArray.push({
                location: new google.maps.LatLng(latLongArray[i][0], latLongArray[i][1]),
                stopover: false
            })
        }
        console.log(wayPointsArray);

    }

    var start = document.getElementById('start').value + ", Victoria, Australia";
    var end = document.getElementById('end').value + ", Victoria, Australia";
    cc('end value: ' + end)
    var request = {
        origin: start,
        destination: end,
        travelMode: google.maps.TravelMode.BICYCLING,
        waypoints: wayPointsArray,
        optimizeWaypoints: true
    };

    directionsService.route(request, function(response, status) {
        if (status == google.maps.DirectionsStatus.OK) {
            directionsDisplay.setDirections(response);
        }
    });
}

google.maps.event.addDomListener(window, 'load', initialize);

var updating = false;

function updateRoutes() {
    if (updating) return;
    updating = true;
    setTimeout(function() {
        updating = false;
    }, 100);
    console.log("Updating routes");

    var routes = this.directions.routes;
    var path = routes[0].overview_path;
    distance = routes[0].legs[0].distance;
    duration = routes[0].legs[0].duration;

    document.getElementById('distance').innerHTML = (distance.value / 1000) + "Km";
    document.getElementById('travel-time').innerHTML = duration.text;

    var pathRequest = {
        'path': path,
        'samples': SAMPLESIZE
    };
    // Send an elevation request to google
    elevation_data.getElevationAlongPath(pathRequest, plotElevation);
}

// Google returns elevation data to the plotElevation
function plotElevation(elevations, status) {
    plotSlope(elevations, SAMPLESIZE);
    cc(elevations, SAMPLESIZE);

}

function plotSlope(elevations, SAMPLESIZE) {

    slopes = [];
    for (i = 0; i < elevations.length - 1; i++) {
        slope = (calcSlope(elevations[i + 1].elevation, elevations[i].elevation, distance.value / SAMPLESIZE)) * 100;
        slopes.push({
            slope: slope,
            location: midpoint(elevations[i], elevations[i + 1])
        });
    }

    drawPolyline(elevations, slopes);

}

function removePolylines() {
    for (var i = 0; i < mapPaths.length; i++) {
        mapPaths[i].setMap(null);
    }
    mapPaths = [];
}

function drawPolyline(elevations, slopes) {
    // Create a polyline between each elevation, color code by slope.
    // Remove any existing polylines before drawing a new polyline.
    removePolylines();
    // Define /reset distanceClimbed, distanceDescended
    var distanceClimbed = 0;
    var distanceDescended = 0;

    for (var i = 0; i < slopes.length; i++) {
        var routePath = [
            elevations[i].location,
            elevations[i + 1].location
        ];


        var currrentSlope = slopes[i].slope;
        if (currrentSlope >= 0 && currrentSlope <= 4) {
            pathColor = "blue";
            distanceClimbed += elevations[i + 1].elevation - elevations[i].elevation;
        } else if (currrentSlope > 4 && currrentSlope <= 8) {
            pathColor = "yellow";
            distanceClimbed += elevations[i + 1].elevation - elevations[i].elevation;
        } else if (currrentSlope > 8 && currrentSlope <= 12) {
            pathColor = "orange";
            distanceClimbed += elevations[i + 1].elevation - elevations[i].elevation;
        } else if (currrentSlope > 12 && currrentSlope <= 20) {
            pathColor = "red";
            distanceClimbed += elevations[i + 1].elevation - elevations[i].elevation;
        } else {
            pathColor = "black";
            distanceDescended += elevations[i].elevation - elevations[i + 1].elevation;
        }
        mapPath = new google.maps.Polyline({
            path: routePath,
            strokeColor: pathColor,
            strokeOpacity: 0.5,
            strokeWeight: 8,
            draggable: true
        });
        mapPath.setMap(map);
        mapPaths.push(mapPath);
    }
    // cc(elevations);
    document.getElementById('climb').innerHTML = distanceClimbed;
    document.getElementById('descent').innerHTML = distanceDescended;
}

function elevationClear(x) {
    map.locationMarker.setMap(null);
}

function midpoint(point1, point2) {
    // To get the midpoint, find the average between each respective point
    var lat = (point1.location.lat() + point2.location.lat()) / 2;
    var lng = (point1.location.lng() + point2.location.lng()) / 2;
    return new google.maps.LatLng(lat, lng);
}

function calcSlope(y1, y2, dx) {
    return (y1 - y2) / dx;
}

function getURLParameter(name) {
    return decodeURIComponent((RegExp(name + '=' + '(.+?)(&|$)')
        .exec(location.search) || [, null])[1]);
}
</script>
