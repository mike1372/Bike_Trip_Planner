<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Slope</title>
<style>

  body{
    margin:0;
  }
canvas{
  width:100%;
  height:80%;
  border: 2px inset brown;
overflow:hidden;
}


/*.dataTables_wrapper{
   overflow:hidden;
}
button{
   float:right;
}*/
.slider {
      overflow-y: hidden;
      max-height: 600px;

      transition-property: all;
      transition-duration: .5s;
      transition-timing-function: cubic-bezier(0, 1, 0.5, 1);

      background: pink;
      height: 600px;
      width: 600px;
    }

    .slider.closed {
      max-height: 0;
    }

#slopeMap{
/*width:50%;
  height:80%;*/
  /*transition: height 200ms;*/
  border: 2px inset green;
}
#menuButton{
  font-size:2em;
  height:3em;
  width:3em;
  /*float:right;*/
}
#menu{
  height:3em;width:3em;
  /*overflow:hidden;*/
}
.medium{height:60%; width:50%;   transition: all 900ms;}
.large{ height:100%;width:100%;  transition: all 900ms;}
button{width:15%;height:3em;}
#slopeMap button{width:19%;height:3em;}
</style>
</head>
<body>






  <div style="height: 50%; width: 50%; border: 1px solid 'yellow';">
    <div class="slider closed" id="slider">
This is informations about our really great app


    </div>
  </div>

  <button onclick="document.getElementById('slider').classList.toggle('closed');">Toggle slider</button>





<div id="slopeMap" class="medium">
<canvas id="c" ></canvas>

<button id="left"><</button>
<button id="right">></button>
<button id="zoomIN">+</button>
<button id="zoomOUT">-</button>
</div>

<button id="up">^</button>
<button id="down">V</button>

  <script>











function cc(a){console.log(a)}
function $id(idTAG){return document.getElementById(idTAG)}
// $id( "zoomIN").onclick=




var X=0,Y=1,Z=2


// data as [ [ x, x1, x2, ... ], [y, y1, y2, ... ], ... ]
data8=[
// x
[-122.41611999999998, -122.4162302874729, -122.41633972398978, -122.41644544522302, -122.4165511679098, -122.41665689205047, -122.4167626176449, -122.41683580774009, -122.41693917469439, -122.41707866489628, -122.41772201092488, -122.41836535554438, -122.4187685444889, -122.41887672320081, -122.41898451127338, -122.41908404164741, -122.4191842315542, -122.41928654360339, -122.41938885706088, -122.41955000000002
], //y
[37.79301, 37.79351732525051, 37.79402476365712, 37.79453269577362, 37.79504062779564, 37.79554855972319, 37.79605649155628, 37.79656785952805, 37.79707603855903, 37.79755639564112, 37.79747549861008, 37.79739459808067, 37.79757778878167, 37.798085398373, 37.79859305790271, 37.79910177124827, 37.79961040296059, 37.80011877181511, 37.80062714058116, 37.80107
], //z
[100.5409851074219, 97.803466796875, 95.05964660644531, 88.70442962646484, 84.35709381103516, 78.30823516845703, 75.63678741455078, 73.07811737060547, 75.09473419189453, 77.38457489013672, 73.762939453125, 69.76280975341797, 69.06586456298828, 71.3529281616211, 74.05626678466797, 78.7208251953125, 82.66853332519531, 88.0782699584961, 92.14973449707031, 90.12250518798828
], //slope as gradient (0-100%)
[0, -2.7375183105469034, -2.7438201904296875, -6.355216979980469, -4.3473358154296875, -6.048858642578125, -2.67144775390625, -2.5586700439453125, 2.0166168212890625, 2.2898406982421875, -3.6216354370117188, -4.000129699707031, -0.6969451904296875, 2.2870635986328125, 2.703338623046875, 4.664558410644531, 3.9477081298828125, 5.409736633300781, 4.071464538574219, -2.0272293090820312
],
[0, -5.041470185169252, -5.053075857144913, -11.70389867399718, -8.006143306500347, -11.139702840843693, -4.919793285278545, -4.712099528444407, 3.7138431331290285, 4.2170178604828505, -6.669678521200219, -7.366721362259726, -1.283508637992058, 4.211903496561349, 4.978524167673804, 8.590346980929157, 7.2701807180162294, 9.962682565931457, 7.498093072880698, -3.733387309543336
]
];


function gMaps3array(elevations){ // [ [x,...], [y,..], ... ]
  var xx=[], yy=[], zz=[], el, X=0,Y=1,Z=2
  for (var i = 0, el; i < elevations.length; i++) {
      el=elevations[i]
      xx.push( el.location.lng() )
      yy.push( el.location.lat() )
      zz.push( el.elevation      )
  };

  // var routes = this.directions.routes;
  // distance = routes[0].legs[0].distance;
  // var SAMPLESIZE = 300
  // var dx = distance.value / SAMPLESIZE
  // var dx =  108.6 //for SAMPLESIZE = 10
  // var dx = 54.3  //for SAMPLESIZE = 20
  // var dx = 3.62 //for SAMPLESIZE = 300
  var dx = 54.3
cc("SAMPLESIZE:");cc(SAMPLESIZE)
cc("dx:");cc(dx)

  var slopes=[0]
  for (var i = 1; i < elevations.length; i++) {
    var dy = zz[i] - zz[i-1]
    slopes.push(dy / dx * 100)
  };
  return [xx, yy, zz, slopes]
};

function toRange(min, max, min1, max1, x) {
  var range0 = max - min
  var range1 = max1 - min1
  return range1 / range0 * (x - min) + min1
}

function maxx(arr, ismax, col) {
  mx = Math[ismax].apply(Math, arr.map(function(v) {
    return v[col];
  }))
  return mx
}
function range(array) {
  return max(array) - min(array)
}

function min(array) {
  return Math.min.apply(Math, array)
}

function max(array) {
  return Math.max.apply(Math, array);
}


function normalize(data8) {
    var X2, Y2, Z2, COLORS, SLOPE=4
    var range0  = max([range(data8[X]), range(data8[Y])]);//keep aspect ratio
    var rangeEl = range(data8[Z])
    var rangeSl = range(data8[SLOPE])
    var min1    = -10// screen coordinates, will be multiplied by 10 to be in range -100,100px
    var minX    = min(data8[X])
    var minY    = min(data8[Y])
    var minZ    = min(data8[Z])
    var minEl   = min(data8[SLOPE])
    var r=100,g=100,b=100
    var dt = 0
  X2 = data8[X].map( function(x){ return 20/range0*(x-minX)+min1} )
  Y2 = data8[Y].map( function(x){ return 20/range0*(x-minY)+min1} )
  Z2 = data8[Z].map( function(x){ return 10/rangeEl*(x-minZ)+0} )
  COLORS = data8[SLOPE].map( function(x){
    r=rnd(255/rangeSl*(x-minEl)+0);
    g=(r>150)?0:50;
    b=(r>120)?50:100;
    return "rgb("+r+","+g+","+b+")"
    } )//rgb
  return [X2, Y2, Z2, COLORS]
}

function data2range(array, range) {
  var min = Math.min.apply(Math, array);
  var max = Math.max.apply(Math, array);
  var min1 = range[0]
  var max1 = range[1]
  return array.map(function(x) {
    return toRange(min, max, min1, max1, x)
  })
}

// d8 = data8.map( function(x){ return data2range(x, [-10,10]) })



// data9.each( function(){ } )


function w(a){console.log(a)}

//-------------
var b   = document.body,
    c   = document.getElementById("c");
c.width = innerWidth*.498;
c.height= innerHeight*0.7;
var t   = c.getContext("2d"),
    totalθ=0,
    totalφ=0,
    f   = 200,
    mX  = 0,
    mY  = 0,
    π   = Math.PI,
    τ   = 2*π,
    sqrt= Math.sqrt,
    cos = Math.cos,
    sin = Math.sin,
    rnd = Math.round,
    centerX = c.width / 2,
    centerY = c.height / 2,
    targetAngleUP=Math.PI*8/6,
    targetAngle=0,
    previous,
    timer=0
    zoom= 0.5,
    zoomTarget= 1.6;
function toggleTimer(){if(timer===0){timer = setInterval(main,0)}}
$id( "right") .onclick = function(){targetAngle += π/4;toggleTimer()}
$id( "left")  .onclick = function(){targetAngle -= π/4;toggleTimer()}
$id( "up")    .onclick = function(){targetAngleUP += π/6;toggleTimer()}
$id( "down")  .onclick = function(){targetAngleUP -= π/6;toggleTimer()}
$id( "zoomIN").onclick = function(){zoomTarget *= 1.3;toggleTimer()}
$id( "zoomOUT").onclick = function(){zoomTarget /= 1.3;toggleTimer()}
// $id( "menuButton").onclick = function(){
//   //var butn=document.getElementById("slopeMap")
// // butn.classList.toggle('large');// >IE9
// // butn.classList.toggle('medium');// >IE9

// document.getElementById("c").classList.toggle('large');// >IE9
// document.getElementById("c").classList.toggle('medium');// >IE9

// }

c.onmousewheel =    function (e) {// chrome only
  // if(!loop)return null
  if        (e.wheelDelta > 0)  zoom *= 1.1
  else if   (e.wheelDelta < 0)  zoom /= 1.1
  if(zoom>maxzoom)zoom=maxzoom
  if(zoom<minzoom)zoom=minzoom}

c.onmousemove = function(e){
  mX = e.clientX;
  mY = e.clientY;
}
c.addEventListener("click", function(event){
  cordinate_x = event.offsetX;
  cordinate_y = event.offsetY;
  console.log( "x,y: ( "+event.offsetX +", "+event.offsetY+" )" )
});

function fnPlane(x,y){
  return  0
}

function fn(x,y){
  var abs = sqrt( x*x + y*y )||1;
  return  π*sin(abs)/abs
}

function createGrid(fn){
  var p = [], rowlength=0, gridx=10, gridy=10, detail=1;
  for(var x = -gridx; x < gridx; x+=detail)
  for(var y = -gridy; y < gridy; y+=detail){
    if( x=== -gridx )rowlength++
    p.push({
      x: x*10,
      y: y*10,
      z: 20*fn(x,y)       })
  }
  p.rowlength=rowlength
  return p
};

function createSlope(arr){
  var p = [], rowlength=arr[0].length;
  for(var i = 0; i < rowlength; i++ ){
    p.push({ x: arr[X][i]*10, y: arr[Y][i]*10, z: arr[Z][i]*10, color:arr[3][i]})
  }

  for(var i = 0; i < rowlength; i++ ){
    p.push({ x: arr[X][i]*10, y: arr[Y][i]*10, z: 0})
  }
  p.rowlength=rowlength
  return p
};

function rotate(plane) {
  var
    θ = π / 4 / 270, //0.002;
    φ = π / 6 / 70,
     zoomINCR = 0.004,
    err = 0.0001
  if ((totalθ < (targetAngle + err)) &&
      (totalθ > (targetAngle - err)) &&
      (totalφ < (targetAngleUP + err)) &&
      (totalφ > (targetAngleUP - err)) &&
      (zoom < (zoomTarget + 0.1)) &&
      (zoom > (zoomTarget - 0.1))
  ) {
    cc("-===")
      // cc("totalφ")
      // cc("totalφ")
    if (timer) {
      clearInterval(timer);
      timer = 0
    }
  }
  if (zoom < zoomTarget) zoom += zoomINCR
  if (zoom > zoomTarget) zoom -= zoomINCR

  if (totalθ < targetAngle) totalθ += θ
  if (totalθ > targetAngle) totalθ -= θ

  if (totalφ < targetAngleUP) totalφ += φ
  if (totalφ > targetAngleUP) totalφ -= φ
    // totalφ+=φ
  θ = totalθ
  φ = totalφ //=π/4
  var
    cosθ = cos(θ),
    sinθ = sin(θ),
    cosφ = cos(φ),
    sinφ = sin(φ),
    pnt, Scale, x1, y1, z1, x, y, z;
  for (var i = plane.length; i--;) {
    pnt = plane[i];
    x = pnt.x;
    y = pnt.y;
    z = pnt.z;

    // x1     = x  * cosθ -  z * sinθ;//rotate XZ, about Y
    // z1     = x  * sinθ +  z * cosθ;
    x1 = x * cosθ - y * sinθ; //rotate XY, about Z
    y1 = x * sinθ + y * cosθ;
    x = x1
    y = y1
    y = y1
    z1 = z * cosφ - y * sinφ; //rotate YZ, about X
    y1 = z * sinφ + y * cosφ;

    Scale = f / (f + z1) * zoom;

    pnt._x = centerX + x1 * Scale;
    pnt._y = centerY + y1 * Scale;
  }

}

function draw(p) {
  t.strokeStyle = "rgb(20,50,20)";
  t.beginPath();
  var rowlength=p.rowlength
  t.moveTo(p[0]._x, p[0]._y);
  var l = rowlength;
  for (var i = 1; i < p.length-rowlength; i++)
    if (i % rowlength) {
      var beneath = i+rowlength;
if(p[i].color){
      t.beginPath();
      t.moveTo(p[i]._x, p[i]._y);
    }
      t.lineTo(p[i]._x,         p[i]._y);
      t.lineTo(p[beneath]._x,   p[beneath]._y);
      t.lineTo(p[beneath-1]._x, p[beneath-1]._y);
      t.lineTo(p[i-1]._x,       p[i-1]._y);
      t.moveTo(p[i]._x,         p[i]._y);
      if(p[i].color){
        t.fillStyle = p[i].color;
        t.fill();
      }
  // t.fillText(i, p[i]._x, p[i]._y)

    }
    else t.moveTo(p[i]._x, p[i]._y);


  t.stroke()
  var now = Date.now();
  dt = now - (previous||0)

  t.fillText("draw time: "+dt, 100, 100)
  t.fillText("angle θ: "+(totalθ/π), 100, 120)
  t.fillText(targetAngle, 100, 140)
  previous = now
}

function drawCircle(x,y,color,radius,txt){
    var oldColor=t.fillStyle
  t.beginPath();
  t.arc(x, y, radius, 0, 2 * Math.PI, false);
  t.fillStyle = color;
  t.fill();
  t.fillStyle = "white";
  t.fillText(txt, x-radius/3, y+radius/3)
  t.fillStyle = oldColor;

}

function drawLine(x1,y1,x2,y2,color){
  var oldColor=t.strokeStyle
  t.beginPath();
  t.moveTo(x1,y1);
  t.lineTo(x2,y2);
  t.strokeStyle = color;
  t.stroke();
  t.strokeStyle = oldColor;
}

function main(){
  t.clearRect(0, 0, c.width, c.height);
  planes.forEach( rotate )
  planes.forEach( draw )
  drawCircle(p[0]._x,p[0]._y,"red",10,"A")
  drawCircle(p[p.rowlength-1]._x,p[p.rowlength-1]._y,"green",10,"B")
}

 p1=createGrid(fn),
 p2=createGrid(fnPlane)
// cc("p1"+p1)
// cc("p2"+p2)
var nXYZ = normalize(data8)
p=createSlope( nXYZ )
// cc(p1.length) [x, y, z, color]
cc(p)
planes=[  p2, p ]
timer = setInterval(main,0);




// ======================= DOM Utility Functions from PastryKit =============================== //

// Sure, we could use jQuery or XUI for these,
// but these are concise and will work with plain vanilla JS

Element.prototype.hasClassName = function (a) {
    return new RegExp("(?:^|\\s+)" + a + "(?:\\s+|$)").test(this.className);
};

Element.prototype.addClassName = function (a) {
    if (!this.hasClassName(a)) {
        this.className = [this.className, a].join(" ");
    }
};

Element.prototype.removeClassName = function (b) {
    if (this.hasClassName(b)) {
        var a = this.className;
        this.className = a.replace(new RegExp("(?:^|\\s+)" + b + "(?:\\s+|$)", "g"), " ");
    }
};

Element.prototype.toggleClassName = function (a) {
  this[this.hasClassName(a) ? "removeClassName" : "addClassName"](a);
};

  </script>


</body>
</html>